# -*- coding: utf-8 -*-
"""Breast Cancer Dataset Clustering and Dimensionality

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11DkXAOrF51eISdEjjIw_qee_30a-a1C0

### Setup

Let's setup Spark on your Colab environment.  Run the cell below!
"""

!pip install pyspark
!pip install -U -q PyDrive
!apt install openjdk-8-jdk-headless -qq
import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"

"""Now we import some of the libraries usually needed by our workload."""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

import pyspark
from pyspark.sql import *
from pyspark.sql.types import *
from pyspark.sql.functions import *
from pyspark import SparkContext, SparkConf

"""Let's initialize the Spark context."""

# create the session
conf = SparkConf().set("spark.ui.port", "4050")

# create the context
sc = pyspark.SparkContext(conf=conf)
spark = SparkSession.builder.getOrCreate()

"""### Data Preprocessing

In this Colab, we will load a famous machine learning dataset, the [Breast Cancer Wisconsin dataset](https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html), using the ```scikit-learn``` datasets loader.
"""

from sklearn.datasets import load_breast_cancer
breast_cancer = load_breast_cancer()

"""For convenience, given that the dataset is small, we first construct a Pandas dataframe, tune the schema, and then convert it into a Spark dataframe."""

pd_df = pd.DataFrame(breast_cancer.data, columns=breast_cancer.feature_names)
df = spark.createDataFrame(pd_df)

def set_df_columns_nullable(spark, df, column_list, nullable=False):
    for struct_field in df.schema:
        if struct_field.name in column_list:
            struct_field.nullable = nullable
    df_mod = spark.createDataFrame(df.rdd, df.schema)
    return df_mod

df = set_df_columns_nullable(spark, df, df.columns)
df = df.withColumn('features', array(df.columns))
vectors = df.rdd.map(lambda row: Vectors.dense(row.features))

df.printSchema()

"""With the next cell, we build the two data structures that we will be using throughout this Colab:


*   ```features```, a dataframe of Dense vectors, containing all the original features in the dataset;
*   ```labels```, a series of binary labels indicating if the corresponding set of features belongs to a subject with breast cancer, or not.


"""

from pyspark.ml.linalg import Vectors
features = spark.createDataFrame(vectors.map(Row), ["features"])
labels = pd.Series(breast_cancer.target)

"""
If you run successfully the Setup and Data Preprocessing stages, you are now ready to cluster the data with the [K-means](https://spark.apache.org/docs/latest/ml-clustering.html) algorithm included in MLlib (Spark's Machine Learning library).
Set the ```k``` parameter to **2**, fit the model, and the compute the [Silhouette score](https://en.wikipedia.org/wiki/Silhouette_(clustering)) (i.e., a measure of quality of the obtained clustering).  

**IMPORTANT:** use the MLlib implementation of the Silhouette score (via ```ClusteringEvaluator```).
"""

from pyspark.ml.clustering import KMeans
from pyspark.ml.evaluation import ClusteringEvaluator

k = 2

kmeans = KMeans().setK(k).setSeed(1)
model = kmeans.fit(features)

predictions = model.transform(features)

evaluator = ClusteringEvaluator()
silhouette_score = evaluator.evaluate(predictions)

print("Silhouette Score:", silhouette_score)

"""Take the predictions produced by K-means, and compare them with the ```labels``` variable (i.e., the ground truth from our dataset).  

Compute how many data points in the dataset have been clustered correctly (i.e., positive cases in one cluster, negative cases in the other).

*HINT*: you can use ```np.count_nonzero(series_a == series_b)``` to quickly compute the element-wise comparison of two series.

**IMPORTANT**: K-means is a clustering algorithm, so it will not output a label for each data point, but just a cluster identifier!  As such, label ```0``` does not necessarily match the cluster identifier ```0```.

"""

import numpy as np

cluster_centers = model.clusterCenters()

def assign_cluster_labels(cluster_indic, ground_truth_labels):
    cluster_lab = []
    for cluster_index in range(len(cluster_centers)):
        cluster_data_indic = np.where(cluster_indic == cluster_index)[0]
        cluster_data_lab = ground_truth_labels[cluster_data_indic]
        class_counts = np.bincount(cluster_data_lab)
        cluster_lab = np.argmax(class_counts)
        cluster_lab.append(cluster_lab)
    return cluster_lab

cluster_indic = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
correctly_clustered = np.count_nonzero(cluster_indic == labels)

print("Number of data points clustered correctly:", correctly_clustered)

"""Now perform dimensionality reduction on the ```features``` using [SVD](https://spark.apache.org/docs/latest/mllib-dimensionality-reduction), available as well in MLlib.

Reduce the dimensionality to **2**, effectively reducing the dataset size of a **15X** factor. Name the new dataset as ```svdFeatures```
"""

from pyspark.ml.feature import PCA

pca = PCA(k=2, inputCol="features", outputCol="svdFeatures")
pca_model = pca.fit(features)

svdFeatures = pca_model.transform(features).select("svdFeatures")
svdFeatures.show()

"""Now run K-means with the same parameters as above, but on the ```svdFeatures``` produced by the SVD reduction you just executed.

Compute the Silhouette score, as well as the number of data points that have been clustered correctly.
"""

kmeans_svd = KMeans().setK(k).setSeed(1).setFeaturesCol("svdFeatures")
model_svd = kmeans_svd.fit(svdFeatures)

predictions_svd = model_svd.transform(svdFeatures)
evaluator_svd = ClusteringEvaluator(predictionCol="prediction", featuresCol="svdFeatures")
silhouette_score_svd = evaluator_svd.evaluate(predictions_svd)

print("Silhouette Score (SVD):", silhouette_score_svd)

# YOUR CODE HERE
cluster_indic_svd = predictions_svd.select("prediction").rdd.flatMap(lambda x: x).collect()
correctly_clustered_svd = np.count_nonzero(cluster_indic_svd == labels)

print("Number of data points clustered correctly (SVD):", correctly_clustered_svd)
